---
title: 'c++ primer 第十六章: 模板与泛型编程'
date: 2023-09-12 23:39:23
tags: 
    - c++ primer
    - c++
---

# 第十六章
模板是泛型编程的基础。一个模板就是一个创建类或者函数的蓝图或者说公式。编译时将模板转换为特定的类或者函数。

## 16.1 模板函数
同一个函数仅类型不同需要定义多个重载函数，不得不重复定义完全一样的函数体

### 16.1.1 函数模板
模板定义以关键字 template 开始，后跟一个模板**参数列表**，可以包含一个或多个以逗号分隔的**模板参数**, 如：
``` c++
template <typename T>
int compare (const T& v1, const T& v2)
{
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

模板参数列表类似函数参数列表。模板参数列表表示在类或者函数定义中用到的类型或值，在使用模板时，需要隐性或显式地制定**模板实参**。

#### 实例化函数模板

调用一个函数模板时，编译器用函数实参来为我们推断模板实参，用推断出的模板参数类实例化一个特定版本的函数，如：

``` c++
compare(1, 0);
// 实例化出： int compare(const int& , const int& ), 
// 以此类推，不同参数类型会实例化出不同函数
```

#### 模板类型参数

模板参数可以是一个类型，如上述 compare 函数，类型参数可以用来指定**返回类型**、**函数参数类型**、**函数体内变量类型或类型转换**。

参数类型前必须使用关键字 class 或 typename，模板参数列表中，这两个关键字含义相同，可以互换。一个模板参数列表中可以同时使用这两个关键字, 建议使用 typename。

``` c++
template <typename T, class U> calc (const T&, const U&);  // 使用正确
```


#### 非类型模板参数

除了类型参数，可以在模板中定义非类型参数，一个类型参数表示一个值，而非一个类型。

模板在被实例化时，非类型参数被一个用户提供或者编译器推断出的**值**所替代。

因为需要编译器在编译时实例化模板，上述**值** 必须时常量表达式。

非参数类型可以是：  
- 整形
- 指向对象或函数类型的指针或引用

相对应的实参：  
- 绑定到整形参数的实参：必须是常量表达式
- 绑定到指针或者引用类型的实参：必须具有静态的生存期，指针参数也可以用 nullptr 或者 0(常量表达式 来实例化)

在模板**定义**内（即函数体内）：模板非类型参数是一个常量值。

例子：
```c++
template <unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M])
{
    return strcmp(p1, p2);
}

compare("hi", "mom");
// 实例化出： int compare(const char (&p1)[3], const char (&p2)[4])
```

#### inline 和 constexpr 函数模板

函数模板可以声明为 inline 或者 constexpr，inline 和 constexpr 放在模板参数列表之后


#### 编写类型无关的代码

模板程序应该尽量减少对实参类型的要求

如上述 compare 函数

- 函数参数是 const 引用： 保证了函数可以用于不能拷贝的类型
- 仅使用 < 比较运算：降低了要处理类型的要求（不必支持 > 运算)  

#### 模板编译
