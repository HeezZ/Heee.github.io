---
title: 背包问题系列
date: 2020-04-27 08:38:43
tags: 
    - 动态规划
    - 算法
    - leetcode
# description: 背包问题系列的解法与变种
---

<!-- toc -->
<!--more-->

#### 0/1背包问题

[参考](https://zhuanlan.zhihu.com/p/78060568)

- **题目**  
有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

- **状态转移方程**

$$F[i, v]=\max \{F[i-1, v], F[i-1, v-C_{i}]+W_{i}\}$$

其中$F[i, v]$表示，前i个物品，最大容量为v时，可以得到的最大价值

- **空间优化**

考虑到状态转移方程中，放第i个物品时，之和第i-1个物品有关，故可以用一维矩阵表示状态

- **算法实现**
```python
# 01背包问题 利用一维数组进行
a=input()
n,m=list(map(int,a.split()))
w=[0 for i in range(n+1)]
v=[0 for i in range(n+1)]
for i in range(1,n+1):
    b=input()
    w[i],v[i]=list(map(int,b.split()))

# 定义一个数组 f[j] 表示容量为j的情况下能放的总价值最大

f=[0 for i in range(m+1)]
# print(f)
for i in range(1,n+1):
    for j in range(m,0,-1):#容量从大到小遍历,可使用同一个dp数组
        if j >=w[i]:
            print(f)
            f[j]=max(f[j],f[j-w[i]]+v[i])
        else:
            break
    # print(f)
# j为容量不断上升 当容量大于当前的时候才可以放下这个
print(f[-1])
```

#### 完全背包
- **题目**
有N 种物品和一个容量为V 的背包，每种物品都有无限件可用。放入第i 种物品的费用是Ci，价值是Wi。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。

- **


#### 分割等和子集

[leetcode 416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)


给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

注意:

每个数组中的元素不会超过 100  
数组的大小不会超过 200  

示例 1:
```
输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].
```

示例 2:
```
输入: [1, 2, 3, 5]
输出: false
解释: 数组不能分割成两个元素和相等的子集.
```
- **状态转移方程**

$\operatorname{dp}[i][j]=\left\{\begin{array}{ll}\mathrm{dp}[i-1][j] \quad or \quad \mathrm{dp}[i-1][j-n u m s[i]] , & \text { nums }[\mathrm{i}]<\mathrm{j} \\ \text { true, } & \text { nums[i] }=\mathrm{j} \end{array}\right.$

$dp[i][j] = True$ 代表前i个元素可以组合成和为j的子数组

- **空间优化**  
与0/1背包问题类似，dp可以用一个一维数组来表示

- **算法实现**
```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) & 1:
            return False
        dp = [False for i in range(sum(nums)//2 + 1)]
        for i in range(len(nums)):
            for m in range(len(dp)-1, -1, -1):
                if m > nums[i]:
                    dp[m] = dp[m-nums[i]] or dp[m]
                if m == nums[i]:
                    dp[m] = True
        return dp[-1]
```
- **算法分析**
    - 时间复杂度：$O(SN)$，其中S表示数组和，N表示数组长度
    - 空间复杂度：$O(N)$




